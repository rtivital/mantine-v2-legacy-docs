{"componentChunkName":"component---src-pages-mdx-slug-tsx","path":"/theming/dark-theme/","result":{"data":{"mdx":{"headings":[{"depth":1,"value":"Dark theme"},{"depth":2,"value":"Colors"},{"depth":2,"value":"Global styles"},{"depth":2,"value":"Color scheme toggle"},{"depth":2,"value":"Save to localStorage and add keyboard shortcut"},{"depth":2,"value":"Detect user preferred color scheme"}],"frontmatter":{"title":"Dark theme","package":null,"slug":"/theming/dark-theme/","props":null,"import":null,"docs":null,"source":null,"description":null,"bundleSize":null,"installation":null,"pageTitle":null,"license":null,"styles":null,"release":null,"date":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"group\": \"theming\",\n  \"title\": \"Dark theme\",\n  \"slug\": \"/theming/dark-theme/\",\n  \"order\": 2\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"dark-theme\"\n  }, \"Dark theme\"), mdx(\"p\", null, \"All mantine components support dark color scheme natively without any additional steps.\\nTo use dark color scheme wrap your application in MantineProvider and specify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"colorScheme\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { MantineProvider } from '@mantine/core';\\n\\nfunction Demo() {\\n  return (\\n    <MantineProvider theme={{ colorScheme: 'dark' }}>\\n      <App />\\n    </MantineProvider>\\n  );\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"colors\"\n  }, \"Colors\"), mdx(\"p\", null, \"Mantine uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors.dark\"), \" values to style components with dark color scheme.\\nDefault colors have purple-blue accent:\"), mdx(ColorsGroup, {\n    group: \"dark\",\n    noTitle: true,\n    mdxType: \"ColorsGroup\"\n  }), mdx(\"p\", null, \"You can customize these values just like any other color:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<MantineProvider\\n  theme={{\\n    colorScheme: 'dark',\\n    colors: {\\n      // override dark colors here to change them for all components\\n      dark: [\\n        '#d5d7e0',\\n        '#acaebf',\\n        '#8c8fa3',\\n        '#666980',\\n        '#4d4f66',\\n        '#34354a',\\n        '#2b2c3d',\\n        '#1d1e30',\\n        '#0c0d21',\\n        '#01010a',\\n      ],\\n    },\\n  }}\\n>\\n  <App />\\n</MantineProvider>\\n\")), mdx(\"h2\", {\n    \"id\": \"global-styles\"\n  }, \"Global styles\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors.dark[7]\"), \" shade is considered to be the body background color and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme.colors.dark[0]\"), \" shade as text color with dark color scheme.\\nYou can create these styles on your own or add \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/theming/global-styles/\"\n  }, \"GlobalStyles\"), \" component, which includes them by default.\\nUsually global styles are added on top level component inside MantineProvider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { MantineProvider, GlobalStyles } from '@mantine/core';\\n\\nfunction Demo() {\\n  return (\\n    <MantineProvider theme={{ colorScheme: 'dark' }}>\\n      <GlobalStyles />\\n      <YourApp />\\n    </MantineProvider>\\n  );\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"color-scheme-toggle\"\n  }, \"Color scheme toggle\"), mdx(\"p\", null, \"Mantine support dynamic color scheme change.\\nTo implement this create context that will save colorScheme value\\nand provide handler to change it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// ColorSchemeContext.jsx file\\nimport { createContext } from 'react';\\n\\nexport default createContext(null);\\n\")), mdx(\"p\", null, \"Then wrap your application with provider:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { MantineProvider } from '@mantine/core';\\nimport ColorSchemeContext from './ColorSchemeContext';\\n\\nexport default function Demo() {\\n  const [colorScheme, setColorScheme] = useState('light');\\n\\n  return (\\n    <ColorSchemeContext.Provider value={{ colorScheme, onChange: setColorScheme }}>\\n      <MantineProvider theme={{ colorScheme }}>\\n        <App />\\n      </MantineProvider>\\n    </ColorSchemeContext.Provider>\\n  );\\n}\\n\")), mdx(\"p\", null, \"And create theme toggle control:\"), mdx(DarkThemeToggleDemo, {\n    mdxType: \"DarkThemeToggleDemo\"\n  }), mdx(\"h2\", {\n    \"id\": \"save-to-localstorage-and-add-keyboard-shortcut\"\n  }, \"Save to localStorage and add keyboard shortcut\"), mdx(\"p\", null, \"If you want to replicate dark theme behavior of Mantine docs website\\nuse \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-local-storage-value/\"\n  }, \"use-local-storage-value\"), \"\\nhook to store theme state in localStorage and sync it across all opened tabs\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-window-event/\"\n  }, \"use-window-event\"), \"\\nto add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ctrl/\\u2318 + J\"), \" keyboard shortcut for theme toggle:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { MantineProvider } from '@mantine/core';\\nimport { useWindowEvent, useLocalStorageValue } from '@mantine/hooks';\\nimport ColorSchemeContext from './ColorSchemeContext';\\n\\nexport default function Demo() {\\n  const [colorScheme, setColorScheme] = useLocalStorageValue({\\n    key: 'mantine-color-scheme',\\n    defaultValue: 'light',\\n  });\\n\\n  useWindowEvent('keydown', (event) => {\\n    if (event.code === 'KeyJ' && (event.ctrlKey || event.metaKey)) {\\n      setColorScheme((current) => (current === 'dark' ? 'light' : 'dark'));\\n    }\\n  });\\n\\n  return (\\n    <ColorSchemeContext.Provider value={{ colorScheme, onChange: setColorScheme }}>\\n      <MantineProvider theme={{ colorScheme }}>\\n        <App />\\n      </MantineProvider>\\n    </ColorSchemeContext.Provider>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Usually saving value to localStorage is not the best strategy as it will create\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://css-tricks.com/flash-of-inaccurate-color-theme-fart/\"\n  }, \"FART\"), \".\\nIf it is possible store user preferred color scheme on server and serve your application without flashes.\"), mdx(\"p\", null, \"For example, Mantine docs are deployed to gh-pages and do not have server (website is fully static) \\u2013\\nin this case if you refresh the page with dark theme, first you will see the prerendered light theme\\nand your selected dark theme will be applied only after a few moments.\"), mdx(\"h2\", {\n    \"id\": \"detect-user-preferred-color-scheme\"\n  }, \"Detect user preferred color scheme\"), mdx(\"p\", null, \"You can detect user preferred color scheme with media query or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-color-scheme/\"\n  }, \"use-color-scheme\"), \"\\nhook and set is as default value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import { MantineProvider } from '@mantine/core';\\nimport { useColorScheme } from '@mantine/hooks';\\nimport ColorSchemeContext from './ColorSchemeContext';\\n\\nexport default function Demo() {\\n  // hook will return either 'dark' or 'light' on client\\n  // and always 'light' during ssr as window.matchMedia is not available\\n  const preferredColorScheme = useColorScheme();\\n  const [colorScheme, setColorScheme] = useState(preferredColorScheme);\\n\\n  return (\\n    <ColorSchemeContext.Provider value={{ colorScheme, onChange: setColorScheme }}>\\n      <MantineProvider theme={{ colorScheme }}>\\n        <App />\\n      </MantineProvider>\\n    </ColorSchemeContext.Provider>\\n  );\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"89cdcf63-8412-55bf-badb-682241b10ae9","slug":"theming/dark-theme","__params":{"slug":"theming"}}},"staticQueryHashes":["2731172446","3701445061","655967936"]}