{"componentChunkName":"component---src-pages-mdx-slug-tsx","path":"/hooks/use-did-update/","result":{"data":{"mdx":{"headings":[{"depth":2,"value":"Usage"},{"depth":2,"value":"Definition"}],"frontmatter":{"title":"use-did-update","package":"@mantine/hooks","slug":"/hooks/use-did-update/","props":null,"import":"import { useDidUpdate } from '@mantine/hooks';","docs":"hooks/use-did-update.mdx","source":"mantine-hooks/src/use-did-update/use-did-update.ts","description":"Call function in useEffect when value changes, but not when component mounts","bundleSize":null,"installation":null,"pageTitle":null,"license":null,"styles":null,"release":null,"date":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"group\": \"mantine-hooks\",\n  \"package\": \"@mantine/hooks\",\n  \"category\": \"lifecycle\",\n  \"title\": \"use-did-update\",\n  \"order\": 1,\n  \"slug\": \"/hooks/use-did-update/\",\n  \"description\": \"Call function in useEffect when value changes, but not when component mounts\",\n  \"import\": \"import { useDidUpdate } from '@mantine/hooks';\",\n  \"docs\": \"hooks/use-did-update.mdx\",\n  \"source\": \"mantine-hooks/src/use-did-update/use-did-update.ts\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"usage\"\n  }, \"Usage\"), mdx(\"p\", null, \"When component mounts useEffect hook is called.\\nThis is fine in most cases but if you need to track value changes and not component mount\\nyou will need to implement something like this to prevent useEffect call on mount:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const mounted = useRef(false);\\n\\nuseEffect(() => {\\n  if (mounted.current) {\\n    fn();\\n  } else {\\n    mounted.current = true;\\n  }\\n}, dependencies);\\n\")), mdx(\"p\", null, \"use-did-update uses the same logic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"useDidUpdate(() => console.log(\\\"Won't be called when mounted\\\"), [value]);\\n\")), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"function useDidUpdate(fn: () => void, dependencies?: any[]): void;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"effb4d16-aa86-5ea1-9f9b-f4d7c0f246df","slug":"hooks/use-did-update","__params":{"slug":"hooks"}}},"staticQueryHashes":["2731172446","3701445061","655967936"]}