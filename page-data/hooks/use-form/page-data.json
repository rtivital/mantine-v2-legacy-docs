{"componentChunkName":"component---src-pages-mdx-slug-tsx","path":"/hooks/use-form/","result":{"data":{"mdx":{"headings":[{"depth":2,"value":"Usage"},{"depth":2,"value":"API"},{"depth":3,"value":"initialValues"},{"depth":3,"value":"validationRules"},{"depth":3,"value":"form.values"},{"depth":3,"value":"form.setFieldValue"},{"depth":3,"value":"form.setValues"},{"depth":3,"value":"form.validate"},{"depth":3,"value":"form.validateField"},{"depth":3,"value":"form.setFieldError"},{"depth":3,"value":"form.setErrors"},{"depth":3,"value":"form.resetErrors"},{"depth":3,"value":"form.reset"},{"depth":3,"value":"form.onSubmit:"},{"depth":2,"value":"Examples"},{"depth":3,"value":"Validate field on blur"},{"depth":3,"value":"External field validation"},{"depth":3,"value":"Authentication form"},{"depth":2,"value":"TypeScript"},{"depth":3,"value":"Definition"},{"depth":3,"value":"Set values type"},{"depth":3,"value":"Get form values type"}],"frontmatter":{"title":"use-form","package":"@mantine/hooks","slug":"/hooks/use-form/","props":null,"import":"import { useForm } from '@mantine/hooks';","docs":"hooks/use-form.mdx","source":"mantine-hooks/src/use-form/use-form.ts","description":"Manage forms state, handles values and validation","bundleSize":null,"installation":null,"pageTitle":null,"license":null,"styles":null,"release":null,"date":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"group\": \"mantine-hooks\",\n  \"package\": \"@mantine/hooks\",\n  \"category\": \"state\",\n  \"title\": \"use-form\",\n  \"order\": 1,\n  \"slug\": \"/hooks/use-form/\",\n  \"description\": \"Manage forms state, handles values and validation\",\n  \"import\": \"import { useForm } from '@mantine/hooks';\",\n  \"docs\": \"hooks/use-form.mdx\",\n  \"source\": \"mantine-hooks/src/use-form/use-form.ts\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"usage\"\n  }, \"Usage\"), mdx(\"p\", null, \"use-form provides bare minimum api to manage simple forms.\\nIt includes handlers to set and validate values.\\nHook does not depend on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@mantine/core\"), \" inputs and does not work with dom.\"), mdx(UseFormBaseDemo, {\n    mdxType: \"UseFormBaseDemo\"\n  }), mdx(\"h2\", {\n    \"id\": \"api\"\n  }, \"API\"), mdx(\"p\", null, \"use-form hook accepts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configuration\"), \" object as single argument:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"initialValues\"), \" \\u2013 object with initial form values\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validationRules\"), \" \\u2013 objects of functions that will be used to validate form values\")), mdx(\"p\", null, \"Hook returns object with properties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"values\"), \" \\u2013 current form values\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setValues\"), \" \\u2013 React useState hook setState action to set \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"values\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setFieldValue\"), \" \\u2013 function to set value of single field\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validate\"), \" \\u2013 function to validate all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"values\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validationRules\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validateField\"), \" \\u2013 function to validate single field value with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validationRules\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"errors\"), \" \\u2013 object of booleans which contains results of running \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validationRules\"), \" functions on corresponding fields\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setFieldError\"), \" \\u2013 function to set single field error in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"errors\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"resetErrors\"), \" \\u2013 function to set all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"errors\"), \" to false\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setErrors\"), \" \\u2013 React useState hook setState action to set \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"errors\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reset\"), \" \\u2013 function to reset all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"values\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"errors\"), \" to initial state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onSubmit\"), \" \\u2013 wrapper function for form onSubmit event handler\")), mdx(\"h3\", {\n    \"id\": \"initialvalues\"\n  }, \"initialValues\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValues\"), \" is required for any form and defines \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form.values\"), \" shape.\\nWhen form is reset with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form.reset\"), \" function these values are set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form.values\"), \".\"), mdx(\"h3\", {\n    \"id\": \"validationrules\"\n  }, \"validationRules\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validationRules\"), \" is an optional object of functions which are used to validate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form.values\"), \".\\nIf you do not need validation in your form, you can skip them:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// Form without validation\\nconst form = useForm({ initialValues: { name: '', age: 0 } });\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validationRules\"), \" must include only keys from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValues\"), \",\\nkeys from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValues\"), \" that do not have corresponding validation rule will always be considered valid.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// validation will run only on name field\\nconst form = useForm({\\n  initialValues: {\\n    name: '',\\n    age: 0, // age field is always valid\\n  },\\n  validationRules: {\\n    // imposter validation rule is noop and will be ignored, ts will complain\\n    imposter: (value) => value.trim().length >= 2,\\n    name: (value) => value.trim().length >= 2,\\n  },\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"formvalues\"\n  }, \"form.values\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values\"), \" contains current values of form, it has the same shape as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValues\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\nform.values; // -> { name: '', age: 0 }\\n\\nform.setFieldValue('name', 'Bob');\\nform.values; // -> { name: 'Bob', age: 0 }\\n\")), mdx(\"h3\", {\n    \"id\": \"formsetfieldvalue\"\n  }, \"form.setFieldValue\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFieldValue\"), \" function sets value at given key on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values\"), \" object:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\n\\nform.setFieldValue('name', 'Bob');\\nform.setFieldValue('age', 25);\\nform.values; // -> { name: 'Bob', age: 25 }\\n\")), mdx(\"p\", null, \"Usually this function is used to work with input elements:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '' } });\\n\\nconst input = (\\n  <input\\n    value={form.values.name}\\n    onChange={(event) => form.setFieldValue('name', event.currentTarget.value)}\\n  />\\n);\\n\")), mdx(\"h3\", {\n    \"id\": \"formsetvalues\"\n  }, \"form.setValues\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setValues\"), \" allows you to set all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values\"), \" with single function call:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\n\\n// setValues with object\\nform.setValues({ name: 'Bob', age: 25 });\\nform.values; // -> { name: 'Bob', age: 25 }\\n\\n// setValues with callback\\nform.setValues((currentValues) => ({ ...currentValues, age: currentValues.age + 10 }));\\nform.values; // -> { name: 'Bob', age: 35 }\\n\")), mdx(\"h3\", {\n    \"id\": \"formvalidate\"\n  }, \"form.validate\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validate\"), \" function runs all validation rules on corresponding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values\"), \" key:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({\\n  initialValues: { name: '', age: 0 },\\n  validationRules: {\\n    name: (value) => value.trim().length >= 2,\\n  },\\n});\\n\\nform.errors; // -> { name: false, age: false }\\n\\nform.validate();\\nform.errors; // -> { name: true, age: false }\\n\\nform.setFieldValue('name', 'Bob');\\nform.validate();\\nform.errors; // -> { name: false, age: false }\\n\")), mdx(\"h3\", {\n    \"id\": \"formvalidatefield\"\n  }, \"form.validateField\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validateField\"), \" function allows you to run validations for individual fields,\\nfor example, it can be useful if you want to validate field when it loses focus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({\\n  initialValues: { name: '', age: 0 },\\n  validationRules: {\\n    name: (value) => value.trim().length >= 2,\\n    age: (value) => value >= 18,\\n  },\\n});\\n\\nform.setFieldValue('age', 12);\\nform.validateField('age');\\nform.errors; // -> { age: true, name: false }\\n\\nform.validateField('name');\\nform.errors; // -> { age: true, name: true }\\n\")), mdx(\"h3\", {\n    \"id\": \"formsetfielderror\"\n  }, \"form.setFieldError\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFieldError\"), \" allows you to bypass validation and manipulate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"errors\"), \" object as you wish.\\nFor example, you can remove error from field once it was focused or perform your own validation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({\\n  initialValues: { name: '', age: 0 },\\n  validationRules: {\\n    name: (value) => value.trim().length >= 2,\\n  },\\n});\\n\\nform.errors; // -> { name: false, age: false }\\n\\nform.setFieldError('name', true);\\nform.errors; // -> { name: true, age: false }\\n\\nform.setFieldError('name', true);\\nform.errors; // -> { name: false, age: false }\\n\")), mdx(\"h3\", {\n    \"id\": \"formseterrors\"\n  }, \"form.setErrors\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setErrors\"), \" sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"errors\"), \" object.\\nUse it when external fields validation occurs, e.g. on server:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\nform.errors; // -> { name: false, age: false }\\n\\n// You can set errors with object\\nform.setErrors({ name: true, age: true });\\nform.errors; // -> { name: true, age: true }\\n\\n// or with callback\\nform.setErrors((errors) => ({\\n  name: !errors.name,\\n  age: !errors.age,\\n}));\\nform.errors; // -> { name: false, age: false }\\n\")), mdx(\"h3\", {\n    \"id\": \"formreseterrors\"\n  }, \"form.resetErrors\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resetErrors\"), \" sets all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"errors\"), \" to false:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\nform.errors; // -> { name: false, age: false }\\n\\nform.setErrors({ name: true, age: true });\\nform.errors; // -> { name: true, age: true }\\n\\nform.resetErrors();\\nform.errors; // -> { name: false, age: false }\\n\")), mdx(\"h3\", {\n    \"id\": \"formreset\"\n  }, \"form.reset\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reset\"), \" function sets all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"errors\"), \" to false and sets \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"values\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialValues\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { name: '', age: 0 } });\\nform.setErrors({ name: true, age: true });\\nform.setValues({ name: 'Bob', age: 25 });\\n\\nform.errors; // -> { name: true, age: true }\\nform.values; // -> { name: 'Bob', age: 25 }\\n\\nform.reset();\\nform.errors; // -> { name: false, age: false }\\nform.values; // -> { name: '', age: 0 }\\n\")), mdx(\"h3\", {\n    \"id\": \"formonsubmit\"\n  }, \"form.onSubmit:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onSubmit\"), \" takes function as an argument and calls it with values if form has no validation errors:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({\\n  initialValues: { name: '', age: 0 },\\n  validationRules: {\\n    name: (value) => value.trim().length >= 2,\\n  },\\n});\\n\\n// console.log will be called with form.values only if\\n// form.validate does not encounter errors\\nconst authForm = <form onSubmit={form.onSubmit((values) => console.log(values))} />;\\n\")), mdx(\"h2\", {\n    \"id\": \"examples\"\n  }, \"Examples\"), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"validate-field-on-blur\"\n  }, \"Validate field on blur\"), mdx(UseFormBlurValidateDemo, {\n    mdxType: \"UseFormBlurValidateDemo\"\n  }), mdx(\"h3\", {\n    \"id\": \"external-field-validation\"\n  }, \"External field validation\"), mdx(\"p\", null, \"Submit form with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test@mantine.dev\"), \" email to see external validation error:\"), mdx(UseFormServerValidationDemo, {\n    mdxType: \"UseFormServerValidationDemo\"\n  }), mdx(\"h3\", {\n    \"id\": \"authentication-form\"\n  }, \"Authentication form\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/mantinedev/mantine/blob/master/src/mantine-demos/src/AuthenticationForm/AuthenticationForm.tsx\"\n  }, \"Browse code on Github\")), mdx(UseFormAuthDemo, {\n    mdxType: \"UseFormAuthDemo\"\n  }), mdx(\"h2\", {\n    \"id\": \"typescript\"\n  }, \"TypeScript\"), mdx(\"h3\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"function useForm<T extends { [key: string]: any }>(configuration: {\\n  initialValues: T;\\n  validationRules?: {\\n    [P in keyof T]?: (value: T[P]) => boolean;\\n  };\\n}): {\\n  values: T;\\n  errors: Record<keyof T, boolean>;\\n  validate: () => boolean;\\n  reset: () => void;\\n  resetErrors: () => void;\\n  setValues: React.Dispatch<React.SetStateAction<T>>;\\n  setErrors: React.Dispatch<React.SetStateAction<Record<keyof T, boolean>>>;\\n  setFieldValue: <K extends keyof T, U extends T[K]>(field: K, value: U) => void;\\n  setFieldError: (field: keyof T, error: boolean) => void;\\n  validateField: (field: keyof T) => void;\\n  onSubmit: (handleSubmit: (values: T) => any) => (event?: React.FormEvent) => void;\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"set-values-type\"\n  }, \"Set values type\"), mdx(\"p\", null, \"use-form will use values types from initialValues, but you can pass your own type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm<{ name?: string; termsOfService?: boolean }>({\\n  initialValues: {\\n    name: '',\\n    termsOfService: false,\\n  },\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"get-form-values-type\"\n  }, \"Get form values type\"), mdx(\"p\", null, \"Use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof\"), \" to get form values type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const form = useForm({ initialValues: { email: '' } });\\n\\nconst handleSubmit = (values: typeof form['values']) => {\\n  // values \\u2013 { email: string }\\n};\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"b4872f58-3f99-5e5b-8f5d-4449f3ec3ea0","slug":"hooks/use-form","__params":{"slug":"hooks"}}},"staticQueryHashes":["2731172446","3701445061","655967936"]}