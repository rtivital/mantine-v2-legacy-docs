{"componentChunkName":"component---src-pages-mdx-slug-tsx","path":"/core/custom-inputs/","result":{"data":{"mdx":{"headings":[{"depth":1,"value":"Building custom inputs"},{"depth":2,"value":"Wrapped Textarea"},{"depth":2,"value":"Custom input with dropdown"},{"depth":3,"value":"Input"},{"depth":3,"value":"InputWrapper"},{"depth":3,"value":"Dropdown"},{"depth":3,"value":"Click outside and focus trap"},{"depth":3,"value":"Animations"}],"frontmatter":{"title":"Custom inputs","package":"@mantine/core","slug":"/core/custom-inputs/","props":null,"import":null,"docs":null,"source":null,"description":null,"bundleSize":null,"installation":null,"pageTitle":null,"license":null,"styles":null,"release":null,"date":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"group\": \"mantine-core\",\n  \"package\": \"@mantine/core\",\n  \"title\": \"Custom inputs\",\n  \"order\": 1,\n  \"slug\": \"/core/custom-inputs/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"building-custom-inputs\"\n  }, \"Building custom inputs\"), mdx(\"p\", null, \"@mantine/core and @mantine/hooks come with all utilities that you need to build custom inputs.\\nThese examples with provide a reference on how to enhance existing components with extra logic to fit your needs\\nand how to use mantine packages to create completely new accessible inputs based on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input/\"\n  }, \"Input\"), \"\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input-wrapper/\"\n  }, \"InputWrapper\"), \" components.\"), mdx(\"h2\", {\n    \"id\": \"wrapped-textarea\"\n  }, \"Wrapped Textarea\"), mdx(\"p\", null, \"First option to create custom input is to enhance existing Mantine component with extra logic and styles.\\nIn this example we will build JsonInput component that adds additional styles and validation logic to Textarea.\"), mdx(\"p\", null, \"JsonInput uses autosize variant of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/textarea/\"\n  }, \"Textarea\"), \"\\ncomponent, which accepts json, validates and formats it.\"), mdx(JsonInputDemo, {\n    mdxType: \"JsonInputDemo\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Key parts:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"styles\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"classNames\"), \" to apply styles to any element (styles applied to input in this example)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onChange\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onFocus\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onBlur\"), \" and all other input related props go directly to input element\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"typeof Textarea\"), \" to get Textarea component props in TypeScript\")), mdx(\"h2\", {\n    \"id\": \"custom-input-with-dropdown\"\n  }, \"Custom input with dropdown\"), mdx(\"p\", null, \"Second option to create custom input is to build everything from scratch.\\nIn this example we will utilize Mantine components and hooks to create accessible color picker component.\"), mdx(\"p\", null, \"ColorInput is a custom input built with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input/\"\n  }, \"Input\"), \"\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input-wrapper/\"\n  }, \"InputWrapper\"), \" components.\"), mdx(ColorInputDemo, {\n    mdxType: \"ColorInputDemo\"\n  }), mdx(\"h3\", {\n    \"id\": \"input\"\n  }, \"Input\"), mdx(\"p\", null, \"For this input we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input/\"\n  }, \"Input\"), \" as button,\\nas we do not want to allow any free user input. We will also grab button ref for future focus management:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<Input\\n  component=\\\"button\\\"\\n  onClick={() => setDropdownOpened(true)}\\n  inputStyle={{ cursor: 'pointer' }}\\n  elementRef={controlRef}\\n  {...others}\\n>\\n  {/*\\n    Since Input is rendered as a button\\n    we can use children to display current value or placeholder\\n  */}\\n  <div style={{ display: 'flex', alignItems: 'center' }}>\\n    <ColorSwatch color={value} size={20} style={{ marginRight: 10 }} />\\n    <Text size=\\\"sm\\\" transform=\\\"uppercase\\\">\\n      {value}\\n    </Text>\\n  </div>\\n</Input>\\n\")), mdx(\"h3\", {\n    \"id\": \"inputwrapper\"\n  }, \"InputWrapper\"), mdx(\"p\", null, \"To give ColorInput component the same label, description and error props as in other Mantine inputs,\\nwe will wrap it with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/input-wrapper/\"\n  }, \"InputWrapper\"), \"\\nand ensure that label is connected to input with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-id/\"\n  }, \"use-id\"), \" hook:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// if input receives id from props, this id will be used,\\n// otherwise random id will be generated\\nconst uuid = useId(id);\\n\\n// We just set InputWrapper props from ColorInput props\\n// It's not a rocket science as you see\\n<InputWrapper required={required} id={uuid} label={label} error={error} description={description}>\\n  <Input id={uuid} /* other input props */ />\\n</InputWrapper>;\\n\")), mdx(\"h3\", {\n    \"id\": \"dropdown\"\n  }, \"Dropdown\"), mdx(\"p\", null, \"Dropdown is built with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/paper/\"\n  }, \"Paper\"), \"\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/color-swatch/\"\n  }, \"ColorSwatch\"), \" components.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"// Colors generated from data prop\\nconst colors = data.map((color) => (\\n  <ColorSwatch\\n    key={color}\\n    // make color swatch interactive, focus styles from theme are already applied\\n    component=\\\"button\\\"\\n    color={color}\\n    onClick={() => handleChange(color)}\\n    style={{ cursor: 'pointer' }}\\n  />\\n));\\n\\nconst dropdown = (\\n  <Paper\\n    // predefined shadow and padding from theme.shadows and theme.spacing\\n    shadow=\\\"md\\\"\\n    padding=\\\"md\\\"\\n    // get element ref for focus trap and click outside\\n    elementRef={dropdownRef}\\n    // Close dropdown when user presses escape\\n    // since focus is trapped inside we do not need to pollute window with this event\\n    onKeyDownCapture={(event) => {\\n      if (event.nativeEvent.code === 'Escape') {\\n        closeDropdown();\\n      }\\n    }}\\n  >\\n    <Group position=\\\"center\\\">{colors}</Group>\\n  </Paper>\\n);\\n\")), mdx(\"h3\", {\n    \"id\": \"click-outside-and-focus-trap\"\n  }, \"Click outside and focus trap\"), mdx(\"p\", null, \"When dropdown is opened usually it is a good idea to trap focus inside\\nand close it with outside clicks. To implement this use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-click-outside/\"\n  }, \"use-click-outside\"), \"\\nand \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-focus-trap/\"\n  }, \"use-focus-trap\"), \".\\nBoth hooks return ref that should be passed to dropdown, to combine them use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/hooks/use-merged-ref/\"\n  }, \"use-merged-ref\"), \"\\nhook:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const focusTrapRef = useFocusTrap();\\nconst clickOutsideRef = useClickOutside(closeDropdown);\\nconst dropdownRef = useMergedRef(focusTrapRef, clickOutsideRef);\\n\\n// on dropdown component\\n<Paper elementRef={dropdownRef} /* ...other dropdown props */ />;\\n\")), mdx(\"h3\", {\n    \"id\": \"animations\"\n  }, \"Animations\"), mdx(\"p\", null, \"To animate dropdown presence we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/core/transition/\"\n  }, \"Transition\"), \"\\ncomponent, it has some premade transitions, for this example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"skew-up\"), \" will do the job:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<Transition\\n  transition=\\\"skew-up\\\"\\n  duration={250}\\n  mounted={dropdownOpened}\\n  onExited={() => setTimeout(() => controlRef.current.focus(), 10)}\\n>\\n  {(transitionStyles) => <Paper style={transitionStyles} /* ...other dropdown props */ />}\\n</Transition>\\n\")), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dropdownOpened\"), \" is false, dropdown will not be mounted to the dom\\n\\u2013 focus trap will have no effect and click outside events will not be registered.\\nWhen dropdown transition is finished we move focus back to control with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onExit\"), \" callback.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"391d1e36-ec5b-5625-8471-ad0f215c6c0a","slug":"core/custom-inputs","__params":{"slug":"core"}}},"staticQueryHashes":["2731172446","3701445061","655967936"]}